"""
Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.
Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов.
Выведите количество различных объектов в этом списке.
Формат ожидаемой программы:
ans = 0
for obj in objects: # доступная переменная objects
    ans += 1

print(ans)

Примечание:
Количеством различных объектов называется максимальный размер множества объектов, в котором любые два объекта являются
различными.
Рассмотрим пример:
objects = [1, 2, 1, 2, 3] # будем считать, что одинаковые числа соответствуют одинаковым объектам,
а различные – различным
Тогда все различные объекты являют собой множество {1, 2, 3}﻿. Таким образом, количество различных
объектов равно трём.
"""
'''
res = set()
objects = [1, 2, 3, 2, 3, 4, 4, 5, 6, 10, 43]
for i in range(len(objects)):
    if objects[i] not in res:
        res.add(objects[i])

print(len(res))
print(res)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
n = len(objects) 100
ans = n 100
for i in range(n): 100
    for j in range(i): 5
        if id(objects[i]) == id(objects[j]):
            ans -= 1
            break

print(ans)
_______________________________________________________________________________________________________________________
'''
'''

def list_sum(lst):
    result = 0
    for element in lst:
        result += element
    return result


def sum(a, b):
    return a + b


y = sum(14, 29)
z = list_sum([1, 2, 3])
print(y)
print(z)
'''
'''
Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:

y больше или равно x
y делится нацело на 5


def closet_mod_5(x):
    while x % 5 != 0:
        x += 1
    return x
______________________________________________________________________________________________________    
def closest_mod_5(x):
    return x if x % 5 == 0 else closest_mod_5(x + 1)

/////////////////////////////////////////////////////////////////////////////////////////////////////////
'''


def C(n, k):
    res = 0
    if k > n:
        return res
    elif k == 0:
        res += 1
        return res
    else:
        res += C(n - 1, k) + C(n - 1, k - 1)
        return res


"""
Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания 
пространств имен и добавление в них переменных.
В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.

Вашей программе на вход подаются следующие запросы:
create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
add <namespace> <var> – добавить в пространство <namespace> переменную <var>
get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из пространства 
<namespace>, или None, если такого пространства не существует
Рассмотрим набор запросов

add global a
create foo global
add foo b
create bar foo
add bar a
Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной 
при выполнении данного кода

a = 0
def foo():
  b = 1
  def bar():
    a = 2
В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. Далее мы объявляем 
функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global. В нашем 
случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, тем самым 
создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.

Добавим запросы get к нашим запросам

get foo a
get foo c
get bar a
get bar b
Представим как это могло бы выглядеть в коде

a = 0
def foo():
  b = 1
  get(a)
  get(c)
  def bar():
    a = 2
    get(a)
    get(b)
Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в 
пространстве global, внутри которого находится пространство foo, она объявлена. Аналогично, результатом запроса get bar 
b будет являться foo, а результатом работы get bar a будет являться bar.

Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не 
была объявлена переменная с.

Более формально, результатом работы get <namespace> <var> является

<namespace>, если в пространстве <namespace> была объявлена переменная <var>
get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, 
если переменная не была объявлена
None, если не существует <parent>, т. е. <namespace>﻿ – это globa
"""

scopes = {
    'global':
        {
            'parent': None, 'vars': set()
        }
}


def create(name_space, parent):
    scopes[name_space] = {'parent': parent, 'vars': set()}


def add(name_space, var):
    scopes[name_space]['vars'] |= {var}


def get(name_space, var):
    if var in scopes[name_space]['vars']:
        return name_space
    if scopes[name_space]['parent'] is None:
        return None
    else:
        return get(scopes[name_space]['parent'], var)


for i in range(int(input())):
    cmd, name_space, var_par = input().split()
    if cmd == 'create':
        create(name_space, var_par)
    elif cmd == 'add':
        add(name_space, var_par)
    else:
        print(get(name_space, var_par))

